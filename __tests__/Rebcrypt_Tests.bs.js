// Generated by BUCKLESCRIPT VERSION 2.2.0, PLEASE EDIT WITH CARE
'use strict';

var Jest = require("@glennsl/bs-jest/src/jest.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebcrypt = require("../src/Rebcrypt.bs.js");

var partial_arg = new RegExp("^\\$2[ayb]\\$.+$");

var partial_arg$1 = Jest.Expect[/* toMatchRe */15];

function toBeASalt(param) {
  return partial_arg$1(partial_arg, param);
}

var partial_arg$2 = new RegExp("^\\$2[ayb]\\$[0-9]{2}\\$[A-Za-z0-9\\.\\/]{53}$");

var partial_arg$3 = Jest.Expect[/* toMatchRe */15];

function toBeAHash(param) {
  return partial_arg$3(partial_arg$2, param);
}

function $great$great(f, g, x) {
  return Curry._1(g, Curry._1(f, x));
}

describe("Salt.genSync", (function () {
        Jest.test("should be able to generate a salt with custom rounds", (function () {
                return toBeASalt(Jest.ExpectJs[/* expect */0](Rebcrypt.Salt[/* toString */0](Rebcrypt.Salt[/* genSync */1](/* Some */[15], /* () */0))));
              }));
        return Jest.test("should be able to generate a salt with default rounds", (function () {
                      return toBeASalt(Jest.ExpectJs[/* expect */0](Rebcrypt.Salt[/* toString */0](Rebcrypt.Salt[/* genSync */1](/* None */0, /* () */0))));
                    }));
      }));

describe("Salt.gen", (function () {
        Jest.testPromise(/* None */0, "should be able to generate a salt with custom rounds", (function () {
                var partial_arg = Jest.ExpectJs[/* expect */0];
                var partial_arg$1 = Rebcrypt.Salt[/* toString */0];
                var partial_arg$2 = function (param) {
                  return Curry._1(partial_arg, Curry._1(partial_arg$1, param));
                };
                var partial_arg$3 = function (param) {
                  return toBeASalt(Curry._1(partial_arg$2, param));
                };
                return Rebcrypt.Salt[/* gen */2](/* Some */[15], /* () */0).then((function (param) {
                              return Promise.resolve(Curry._1(partial_arg$3, param));
                            }));
              }));
        return Jest.testPromise(/* None */0, "should be able to generate a salt with default rounds", (function () {
                      var partial_arg = Jest.ExpectJs[/* expect */0];
                      var partial_arg$1 = Rebcrypt.Salt[/* toString */0];
                      var partial_arg$2 = function (param) {
                        return Curry._1(partial_arg, Curry._1(partial_arg$1, param));
                      };
                      var partial_arg$3 = function (param) {
                        return toBeASalt(Curry._1(partial_arg$2, param));
                      };
                      return Rebcrypt.Salt[/* gen */2](/* None */0, /* () */0).then((function (param) {
                                    return Promise.resolve(Curry._1(partial_arg$3, param));
                                  }));
                    }));
      }));

describe("Hash.makeSync", (function () {
        var salt = Rebcrypt.Salt[/* genSync */1](/* None */0, /* () */0);
        return Jest.test("should be able to hash a string", (function () {
                      return toBeAHash(Jest.ExpectJs[/* expect */0](Rebcrypt.Hash[/* toString */0](Rebcrypt.Hash[/* makeSync */2]("REALLY_STRING_PASSWORD", salt))));
                    }));
      }));

describe("Hash.make", (function () {
        var salt = Rebcrypt.Salt[/* genSync */1](/* None */0, /* () */0);
        return Jest.testPromise(/* None */0, "should be able to hash a string", (function () {
                      var partial_arg = Jest.ExpectJs[/* expect */0];
                      var partial_arg$1 = Rebcrypt.Hash[/* toString */0];
                      var partial_arg$2 = function (param) {
                        return Curry._1(partial_arg, Curry._1(partial_arg$1, param));
                      };
                      var partial_arg$3 = function (param) {
                        return toBeAHash(Curry._1(partial_arg$2, param));
                      };
                      return Rebcrypt.Hash[/* make */3]("REALLY_STRING_PASSWORD", salt).then((function (param) {
                                    return Promise.resolve(Curry._1(partial_arg$3, param));
                                  }));
                    }));
      }));

describe("hashAndSalt", (function () {
        Jest.testPromise(/* None */0, "should be able to hash a string with default rounds", (function () {
                var partial_arg = Jest.ExpectJs[/* expect */0];
                var partial_arg$1 = Rebcrypt.Hash[/* toString */0];
                var partial_arg$2 = function (param) {
                  return Curry._1(partial_arg, Curry._1(partial_arg$1, param));
                };
                var partial_arg$3 = function (param) {
                  return toBeAHash(Curry._1(partial_arg$2, param));
                };
                return Rebcrypt.hashAndSalt(/* None */0, "REALLY_STRING_PASSWORD").then((function (param) {
                              return Promise.resolve(Curry._1(partial_arg$3, param));
                            }));
              }));
        return Jest.testPromise(/* None */0, "should be able to hash a string with custom rounds", (function () {
                      var partial_arg = Jest.ExpectJs[/* expect */0];
                      var partial_arg$1 = Rebcrypt.Hash[/* toString */0];
                      var partial_arg$2 = function (param) {
                        return Curry._1(partial_arg, Curry._1(partial_arg$1, param));
                      };
                      var partial_arg$3 = function (param) {
                        return toBeAHash(Curry._1(partial_arg$2, param));
                      };
                      return Rebcrypt.hashAndSalt(/* Some */[5], "REALLY_STRING_PASSWORD").then((function (param) {
                                    return Promise.resolve(Curry._1(partial_arg$3, param));
                                  }));
                    }));
      }));

describe("hashAndSaltSync", (function () {
        Jest.test("should be able to hash a string with default rounds", (function () {
                return toBeAHash(Jest.ExpectJs[/* expect */0](Rebcrypt.Hash[/* toString */0](Rebcrypt.hashAndSaltSync(/* None */0, "REALLY_STRING_PASSWORD"))));
              }));
        return Jest.test("should be able to hash a string with custom rounds", (function () {
                      return toBeAHash(Jest.ExpectJs[/* expect */0](Rebcrypt.Hash[/* toString */0](Rebcrypt.hashAndSaltSync(/* Some */[5], "REALLY_STRING_PASSWORD"))));
                    }));
      }));

describe("Hash.compare", (function () {
        Jest.testPromise(/* None */0, "Identical passwords should hash to the same value", (function () {
                var partial_arg = Jest.ExpectJs[/* toBeTruthy */28];
                var partial_arg$1 = Jest.ExpectJs[/* expect */0];
                var partial_arg$2 = function (param) {
                  return Curry._1(partial_arg, Curry._1(partial_arg$1, param));
                };
                return Rebcrypt.hashAndSalt(/* None */0, "REALLY_STRING_PASSWORD").then((function (h) {
                                return Rebcrypt.Hash[/* compare */5]("REALLY_STRING_PASSWORD", h);
                              })).then((function (param) {
                              return Promise.resolve(Curry._1(partial_arg$2, param));
                            }));
              }));
        Jest.testPromise(/* None */0, "Different passwords should hash to the different values", (function () {
                var partial_arg = Jest.ExpectJs[/* toBeFalsy */26];
                var partial_arg$1 = Jest.ExpectJs[/* expect */0];
                var partial_arg$2 = function (param) {
                  return Curry._1(partial_arg, Curry._1(partial_arg$1, param));
                };
                return Rebcrypt.hashAndSalt(/* None */0, "REALLY_WEEK_PASSWORD").then((function (h) {
                                return Rebcrypt.Hash[/* compare */5]("REALLY_STRING_PASSWORD", h);
                              })).then((function (param) {
                              return Promise.resolve(Curry._1(partial_arg$2, param));
                            }));
              }));
        return Jest.testPromise(/* None */0, "Identical hashed with different number of rounds should hash to the same value", (function () {
                      var partial_arg = Jest.ExpectJs[/* toBeTruthy */28];
                      var partial_arg$1 = Jest.ExpectJs[/* expect */0];
                      var partial_arg$2 = function (param) {
                        return Curry._1(partial_arg, Curry._1(partial_arg$1, param));
                      };
                      var partial_arg$3 = Rebcrypt.Hash[/* compare */5];
                      return Rebcrypt.hashAndSalt(/* Some */[4], "REALLY_STRING_PASSWORD").then((function (param) {
                                      return partial_arg$3("REALLY_STRING_PASSWORD", param);
                                    })).then((function (param) {
                                    return Promise.resolve(Curry._1(partial_arg$2, param));
                                  }));
                    }));
      }));

describe("Hash.compareSync", (function () {
        Jest.test("Identical passwords should hash to the same value", (function () {
                var x = Rebcrypt.Hash[/* compareSync */4]("REALLY_STRING_PASSWORD", Rebcrypt.hashAndSaltSync(/* None */0, "REALLY_STRING_PASSWORD"));
                return Jest.ExpectJs[/* toBeTruthy */28](Jest.ExpectJs[/* expect */0](x));
              }));
        Jest.test("Different passwords should hash to the different values", (function () {
                var x = Rebcrypt.Hash[/* compareSync */4]("REALLY_STRING_PASSWORD", Rebcrypt.hashAndSaltSync(/* None */0, "REALLY_WEEK_PASSWORD"));
                return Jest.ExpectJs[/* toBeFalsy */26](Jest.ExpectJs[/* expect */0](x));
              }));
        return Jest.test("Identical hashed with different number of rounds should hash to the same value", (function () {
                      var x = Rebcrypt.Hash[/* compareSync */4]("REALLY_STRING_PASSWORD", Rebcrypt.hashAndSaltSync(/* Some */[4], "REALLY_STRING_PASSWORD"));
                      return Jest.ExpectJs[/* toBeTruthy */28](Jest.ExpectJs[/* expect */0](x));
                    }));
      }));

describe("getRounds", (function () {
        return Jest.test("Should get the correct number of rounds", (function () {
                      return Jest.ExpectJs[/* toEqual */12](4, Jest.ExpectJs[/* expect */0](Rebcrypt.Hash[/* getRounds */1](Rebcrypt.hashAndSaltSync(/* Some */[4], "REALLY_STRING_PASSWORD"))));
                    }));
      }));

exports.toBeASalt = toBeASalt;
exports.toBeAHash = toBeAHash;
exports.$great$great = $great$great;
/* partial_arg Not a pure module */
